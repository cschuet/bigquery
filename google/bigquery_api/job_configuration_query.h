// Copyright 2010 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

// This code was generated by google-apis-code-generator 1.5.1
//   Build date: 2018-10-08 17:45:39 UTC
//   on: 2019-03-01, 03:01:16 UTC
//   C++ generator version: 0.1.4

// ----------------------------------------------------------------------------
// NOTE: This file is generated from Google APIs Discovery Service.
// Service:
//   BigQuery API (bigquery/v2)
// Generated from:
//   Version: v2
//   Revision: 427
// Generated by:
//    Tool: google-apis-code-generator 1.5.1
//     C++: 0.1.4
#ifndef  GOOGLE_BIGQUERY_API_JOB_CONFIGURATION_QUERY_H_
#define  GOOGLE_BIGQUERY_API_JOB_CONFIGURATION_QUERY_H_

#include <string>
#include "googleapis/base/integral_types.h"
#include "googleapis/base/macros.h"
#include "googleapis/client/data/jsoncpp_data.h"
#include "googleapis/strings/stringpiece.h"

#include "google/bigquery_api/clustering.h"
#include "google/bigquery_api/dataset_reference.h"
#include "google/bigquery_api/encryption_configuration.h"
#include "google/bigquery_api/external_data_configuration.h"
#include "google/bigquery_api/query_parameter.h"
#include "google/bigquery_api/range_partitioning.h"
#include "google/bigquery_api/table_reference.h"
#include "google/bigquery_api/time_partitioning.h"
#include "google/bigquery_api/user_defined_function_resource.h"

namespace Json {
class Value;
}  // namespace Json

namespace google_bigquery_api {
using namespace googleapis;

/**
 * No description provided.
 *
 * @ingroup DataObject
 */
class JobConfigurationQuery : public client::JsonCppData {
 public:
  /**
   * Creates a new default instance.
   *
   * @return Ownership is passed back to the caller.
   */
  static JobConfigurationQuery* New();

  /**
   * Standard constructor for an immutable data object instance.
   *
   * @param[in] storage  The underlying data storage for this instance.
   */
  explicit JobConfigurationQuery(const Json::Value& storage);

  /**
   * Standard constructor for a mutable data object instance.
   *
   * @param[in] storage  The underlying data storage for this instance.
   */
  explicit JobConfigurationQuery(Json::Value* storage);

  /**
   * Standard destructor.
   */
  virtual ~JobConfigurationQuery();

  /**
   * Returns a string denoting the type of this data object.
   *
   * @return <code>google_bigquery_api::JobConfigurationQuery</code>
   */
  const StringPiece GetTypeName() const {
    return StringPiece("google_bigquery_api::JobConfigurationQuery");
  }

  /**
   * Determine if the '<code>allowLargeResults</code>' attribute was set.
   *
   * @return true if the '<code>allowLargeResults</code>' attribute was set.
   */
  bool has_allow_large_results() const {
    return Storage().isMember("allowLargeResults");
  }

  /**
   * Clears the '<code>allowLargeResults</code>' attribute.
   */
  void clear_allow_large_results() {
    MutableStorage()->removeMember("allowLargeResults");
  }


  /**
   * Get the value of the '<code>allowLargeResults</code>' attribute.
   */
  bool get_allow_large_results() const {
    const Json::Value& storage = Storage("allowLargeResults");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>allowLargeResults</code>' attribute.
   *
   * [Optional] If true and query uses legacy SQL dialect, allows the query to
   * produce arbitrarily large result tables at a slight cost in performance.
   * Requires destinationTable to be set. For standard SQL queries, this flag is
   * ignored and large results are always allowed. However, you must still set
   * destinationTable when result size exceeds the allowed maximum response
   * size.
   *
   * @param[in] value The new value.
   */
  void set_allow_large_results(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("allowLargeResults"));
  }

  /**
   * Determine if the '<code>clustering</code>' attribute was set.
   *
   * @return true if the '<code>clustering</code>' attribute was set.
   */
  bool has_clustering() const {
    return Storage().isMember("clustering");
  }

  /**
   * Clears the '<code>clustering</code>' attribute.
   */
  void clear_clustering() {
    MutableStorage()->removeMember("clustering");
  }


  /**
   * Get a reference to the value of the '<code>clustering</code>' attribute.
   */
  const Clustering get_clustering() const;

  /**
   * Gets a reference to a mutable value of the '<code>clustering</code>'
   * property.
   *
   * [Beta] Clustering specification for the destination table. Must be
   * specified with time-based partitioning, data in the table will be first
   * partitioned and subsequently clustered.
   *
   * @return The result can be modified to change the attribute value.
   */
  Clustering mutable_clustering();

  /**
   * Determine if the '<code>createDisposition</code>' attribute was set.
   *
   * @return true if the '<code>createDisposition</code>' attribute was set.
   */
  bool has_create_disposition() const {
    return Storage().isMember("createDisposition");
  }

  /**
   * Clears the '<code>createDisposition</code>' attribute.
   */
  void clear_create_disposition() {
    MutableStorage()->removeMember("createDisposition");
  }


  /**
   * Get the value of the '<code>createDisposition</code>' attribute.
   */
  const StringPiece get_create_disposition() const {
    const Json::Value& v = Storage("createDisposition");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>createDisposition</code>' attribute.
   *
   * [Optional] Specifies whether the job is allowed to create new tables. The
   * following values are supported: CREATE_IF_NEEDED: If the table does not
   * exist, BigQuery creates the table. CREATE_NEVER: The table must already
   * exist. If it does not, a 'notFound' error is returned in the job result.
   * The default value is CREATE_IF_NEEDED. Creation, truncation and append
   * actions occur as one atomic update upon job completion.
   *
   * @param[in] value The new value.
   */
  void set_create_disposition(const StringPiece& value) {
    *MutableStorage("createDisposition") = value.data();
  }

  /**
   * Determine if the '<code>defaultDataset</code>' attribute was set.
   *
   * @return true if the '<code>defaultDataset</code>' attribute was set.
   */
  bool has_default_dataset() const {
    return Storage().isMember("defaultDataset");
  }

  /**
   * Clears the '<code>defaultDataset</code>' attribute.
   */
  void clear_default_dataset() {
    MutableStorage()->removeMember("defaultDataset");
  }


  /**
   * Get a reference to the value of the '<code>defaultDataset</code>'
   * attribute.
   */
  const DatasetReference get_default_dataset() const;

  /**
   * Gets a reference to a mutable value of the '<code>defaultDataset</code>'
   * property.
   *
   * [Optional] Specifies the default dataset to use for unqualified table names
   * in the query. Note that this does not alter behavior of unqualified dataset
   * names.
   *
   * @return The result can be modified to change the attribute value.
   */
  DatasetReference mutable_defaultDataset();

  /**
   * Determine if the '<code>destinationEncryptionConfiguration</code>'
   * attribute was set.
   *
   * @return true if the '<code>destinationEncryptionConfiguration</code>'
   * attribute was set.
   */
  bool has_destination_encryption_configuration() const {
    return Storage().isMember("destinationEncryptionConfiguration");
  }

  /**
   * Clears the '<code>destinationEncryptionConfiguration</code>' attribute.
   */
  void clear_destination_encryption_configuration() {
    MutableStorage()->removeMember("destinationEncryptionConfiguration");
  }


  /**
   * Get a reference to the value of the
   * '<code>destinationEncryptionConfiguration</code>' attribute.
   */
  const EncryptionConfiguration get_destination_encryption_configuration() const;

  /**
   * Gets a reference to a mutable value of the
   * '<code>destinationEncryptionConfiguration</code>' property.
   *
   * Custom encryption configuration (e.g., Cloud KMS keys).
   *
   * @return The result can be modified to change the attribute value.
   */
  EncryptionConfiguration mutable_destinationEncryptionConfiguration();

  /**
   * Determine if the '<code>destinationTable</code>' attribute was set.
   *
   * @return true if the '<code>destinationTable</code>' attribute was set.
   */
  bool has_destination_table() const {
    return Storage().isMember("destinationTable");
  }

  /**
   * Clears the '<code>destinationTable</code>' attribute.
   */
  void clear_destination_table() {
    MutableStorage()->removeMember("destinationTable");
  }


  /**
   * Get a reference to the value of the '<code>destinationTable</code>'
   * attribute.
   */
  const TableReference get_destination_table() const;

  /**
   * Gets a reference to a mutable value of the '<code>destinationTable</code>'
   * property.
   *
   * [Optional] Describes the table where the query results should be stored. If
   * not present, a new table will be created to store the results. This
   * property must be set for large results that exceed the maximum response
   * size.
   *
   * @return The result can be modified to change the attribute value.
   */
  TableReference mutable_destinationTable();

  /**
   * Determine if the '<code>flattenResults</code>' attribute was set.
   *
   * @return true if the '<code>flattenResults</code>' attribute was set.
   */
  bool has_flatten_results() const {
    return Storage().isMember("flattenResults");
  }

  /**
   * Clears the '<code>flattenResults</code>' attribute.
   */
  void clear_flatten_results() {
    MutableStorage()->removeMember("flattenResults");
  }


  /**
   * Get the value of the '<code>flattenResults</code>' attribute.
   */
  bool get_flatten_results() const {
    const Json::Value& storage = Storage("flattenResults");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>flattenResults</code>' attribute.
   *
   * [Optional] If true and query uses legacy SQL dialect, flattens all nested
   * and repeated fields in the query results. allowLargeResults must be true if
   * this is set to false. For standard SQL queries, this flag is ignored and
   * results are never flattened.
   *
   * @param[in] value The new value.
   */
  void set_flatten_results(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("flattenResults"));
  }

  /**
   * Determine if the '<code>maximumBillingTier</code>' attribute was set.
   *
   * @return true if the '<code>maximumBillingTier</code>' attribute was set.
   */
  bool has_maximum_billing_tier() const {
    return Storage().isMember("maximumBillingTier");
  }

  /**
   * Clears the '<code>maximumBillingTier</code>' attribute.
   */
  void clear_maximum_billing_tier() {
    MutableStorage()->removeMember("maximumBillingTier");
  }


  /**
   * Get the value of the '<code>maximumBillingTier</code>' attribute.
   */
  int32 get_maximum_billing_tier() const {
    const Json::Value& storage = Storage("maximumBillingTier");
    return client::JsonValueToCppValueHelper<int32 >(storage);
  }

  /**
   * Change the '<code>maximumBillingTier</code>' attribute.
   *
   * [Optional] Limits the billing tier for this job. Queries that have resource
   * usage beyond this tier will fail (without incurring a charge). If
   * unspecified, this will be set to your project default.
   *
   * @param[in] value The new value.
   */
  void set_maximum_billing_tier(int32 value) {
    client::SetJsonValueFromCppValueHelper<int32 >(
      value, MutableStorage("maximumBillingTier"));
  }

  /**
   * Determine if the '<code>maximumBytesBilled</code>' attribute was set.
   *
   * @return true if the '<code>maximumBytesBilled</code>' attribute was set.
   */
  bool has_maximum_bytes_billed() const {
    return Storage().isMember("maximumBytesBilled");
  }

  /**
   * Clears the '<code>maximumBytesBilled</code>' attribute.
   */
  void clear_maximum_bytes_billed() {
    MutableStorage()->removeMember("maximumBytesBilled");
  }


  /**
   * Get the value of the '<code>maximumBytesBilled</code>' attribute.
   */
  int64 get_maximum_bytes_billed() const {
    const Json::Value& storage = Storage("maximumBytesBilled");
    return client::JsonValueToCppValueHelper<int64 >(storage);
  }

  /**
   * Change the '<code>maximumBytesBilled</code>' attribute.
   *
   * [Optional] Limits the bytes billed for this job. Queries that will have
   * bytes billed beyond this limit will fail (without incurring a charge). If
   * unspecified, this will be set to your project default.
   *
   * @param[in] value The new value.
   */
  void set_maximum_bytes_billed(int64 value) {
    client::SetJsonValueFromCppValueHelper<int64 >(
      value, MutableStorage("maximumBytesBilled"));
  }

  /**
   * Determine if the '<code>parameterMode</code>' attribute was set.
   *
   * @return true if the '<code>parameterMode</code>' attribute was set.
   */
  bool has_parameter_mode() const {
    return Storage().isMember("parameterMode");
  }

  /**
   * Clears the '<code>parameterMode</code>' attribute.
   */
  void clear_parameter_mode() {
    MutableStorage()->removeMember("parameterMode");
  }


  /**
   * Get the value of the '<code>parameterMode</code>' attribute.
   */
  const StringPiece get_parameter_mode() const {
    const Json::Value& v = Storage("parameterMode");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>parameterMode</code>' attribute.
   *
   * Standard SQL only. Set to POSITIONAL to use positional (?) query parameters
   * or to NAMED to use named (@myparam) query parameters in this query.
   *
   * @param[in] value The new value.
   */
  void set_parameter_mode(const StringPiece& value) {
    *MutableStorage("parameterMode") = value.data();
  }

  /**
   * Determine if the '<code>preserveNulls</code>' attribute was set.
   *
   * @return true if the '<code>preserveNulls</code>' attribute was set.
   */
  bool has_preserve_nulls() const {
    return Storage().isMember("preserveNulls");
  }

  /**
   * Clears the '<code>preserveNulls</code>' attribute.
   */
  void clear_preserve_nulls() {
    MutableStorage()->removeMember("preserveNulls");
  }


  /**
   * Get the value of the '<code>preserveNulls</code>' attribute.
   */
  bool get_preserve_nulls() const {
    const Json::Value& storage = Storage("preserveNulls");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>preserveNulls</code>' attribute.
   * @deprecated
   *
   *
   * [Deprecated] This property is deprecated.
   *
   * @param[in] value The new value.
   */
  void set_preserve_nulls(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("preserveNulls"));
  }

  /**
   * Determine if the '<code>priority</code>' attribute was set.
   *
   * @return true if the '<code>priority</code>' attribute was set.
   */
  bool has_priority() const {
    return Storage().isMember("priority");
  }

  /**
   * Clears the '<code>priority</code>' attribute.
   */
  void clear_priority() {
    MutableStorage()->removeMember("priority");
  }


  /**
   * Get the value of the '<code>priority</code>' attribute.
   */
  const StringPiece get_priority() const {
    const Json::Value& v = Storage("priority");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>priority</code>' attribute.
   *
   * [Optional] Specifies a priority for the query. Possible values include
   * INTERACTIVE and BATCH. The default value is INTERACTIVE.
   *
   * @param[in] value The new value.
   */
  void set_priority(const StringPiece& value) {
    *MutableStorage("priority") = value.data();
  }

  /**
   * Determine if the '<code>query</code>' attribute was set.
   *
   * @return true if the '<code>query</code>' attribute was set.
   */
  bool has_query() const {
    return Storage().isMember("query");
  }

  /**
   * Clears the '<code>query</code>' attribute.
   */
  void clear_query() {
    MutableStorage()->removeMember("query");
  }


  /**
   * Get the value of the '<code>query</code>' attribute.
   */
  const StringPiece get_query() const {
    const Json::Value& v = Storage("query");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>query</code>' attribute.
   *
   * [Required] SQL query text to execute. The useLegacySql field can be used to
   * indicate whether the query uses legacy SQL or standard SQL.
   *
   * @param[in] value The new value.
   */
  void set_query(const StringPiece& value) {
    *MutableStorage("query") = value.data();
  }

  /**
   * Determine if the '<code>queryParameters</code>' attribute was set.
   *
   * @return true if the '<code>queryParameters</code>' attribute was set.
   */
  bool has_query_parameters() const {
    return Storage().isMember("queryParameters");
  }

  /**
   * Clears the '<code>queryParameters</code>' attribute.
   */
  void clear_query_parameters() {
    MutableStorage()->removeMember("queryParameters");
  }


  /**
   * Get a reference to the value of the '<code>queryParameters</code>'
   * attribute.
   */
  const client::JsonCppArray<QueryParameter > get_query_parameters() const;

  /**
   * Gets a reference to a mutable value of the '<code>queryParameters</code>'
   * property.
   *
   * Query parameters for standard SQL queries.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppArray<QueryParameter > mutable_queryParameters();

  /**
   * Determine if the '<code>rangePartitioning</code>' attribute was set.
   *
   * @return true if the '<code>rangePartitioning</code>' attribute was set.
   */
  bool has_range_partitioning() const {
    return Storage().isMember("rangePartitioning");
  }

  /**
   * Clears the '<code>rangePartitioning</code>' attribute.
   */
  void clear_range_partitioning() {
    MutableStorage()->removeMember("rangePartitioning");
  }


  /**
   * Get a reference to the value of the '<code>rangePartitioning</code>'
   * attribute.
   */
  const RangePartitioning get_range_partitioning() const;

  /**
   * Gets a reference to a mutable value of the '<code>rangePartitioning</code>'
   * property.
   *
   * [TrustedTester] Range partitioning specification for this table. Only one
   * of timePartitioning and rangePartitioning should be specified.
   *
   * @return The result can be modified to change the attribute value.
   */
  RangePartitioning mutable_rangePartitioning();

  /**
   * Determine if the '<code>schemaUpdateOptions</code>' attribute was set.
   *
   * @return true if the '<code>schemaUpdateOptions</code>' attribute was set.
   */
  bool has_schema_update_options() const {
    return Storage().isMember("schemaUpdateOptions");
  }

  /**
   * Clears the '<code>schemaUpdateOptions</code>' attribute.
   */
  void clear_schema_update_options() {
    MutableStorage()->removeMember("schemaUpdateOptions");
  }


  /**
   * Get a reference to the value of the '<code>schemaUpdateOptions</code>'
   * attribute.
   */
  const client::JsonCppArray<string > get_schema_update_options() const {
     const Json::Value& storage = Storage("schemaUpdateOptions");
    return client::JsonValueToCppValueHelper<client::JsonCppArray<string > >(storage);
  }

  /**
   * Gets a reference to a mutable value of the
   * '<code>schemaUpdateOptions</code>' property.
   *
   * Allows the schema of the destination table to be updated as a side effect
   * of the query job. Schema update options are supported in two cases: when
   * writeDisposition is WRITE_APPEND; when writeDisposition is WRITE_TRUNCATE
   * and the destination table is a partition of a table, specified by partition
   * decorators. For normal tables, WRITE_TRUNCATE will always overwrite the
   * schema. One or more of the following values are specified:
   * ALLOW_FIELD_ADDITION: allow adding a nullable field to the schema.
   * ALLOW_FIELD_RELAXATION: allow relaxing a required field in the original
   * schema to nullable.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppArray<string > mutable_schemaUpdateOptions() {
    Json::Value* storage = MutableStorage("schemaUpdateOptions");
    return client::JsonValueToMutableCppValueHelper<client::JsonCppArray<string > >(storage);
  }

  /**
   * Determine if the '<code>tableDefinitions</code>' attribute was set.
   *
   * @return true if the '<code>tableDefinitions</code>' attribute was set.
   */
  bool has_table_definitions() const {
    return Storage().isMember("tableDefinitions");
  }

  /**
   * Clears the '<code>tableDefinitions</code>' attribute.
   */
  void clear_table_definitions() {
    MutableStorage()->removeMember("tableDefinitions");
  }


  /**
   * Get a reference to the value of the '<code>tableDefinitions</code>'
   * attribute.
   */
  const client::JsonCppAssociativeArray<ExternalDataConfiguration > get_table_definitions() const;

  /**
   * Gets a reference to a mutable value of the '<code>tableDefinitions</code>'
   * property.
   *
   * [Optional] If querying an external data source outside of BigQuery,
   * describes the data format, location and other properties of the data
   * source. By defining these properties, the data source can then be queried
   * as if it were a standard BigQuery table.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppAssociativeArray<ExternalDataConfiguration > mutable_tableDefinitions();

  /**
   * Determine if the '<code>timePartitioning</code>' attribute was set.
   *
   * @return true if the '<code>timePartitioning</code>' attribute was set.
   */
  bool has_time_partitioning() const {
    return Storage().isMember("timePartitioning");
  }

  /**
   * Clears the '<code>timePartitioning</code>' attribute.
   */
  void clear_time_partitioning() {
    MutableStorage()->removeMember("timePartitioning");
  }


  /**
   * Get a reference to the value of the '<code>timePartitioning</code>'
   * attribute.
   */
  const TimePartitioning get_time_partitioning() const;

  /**
   * Gets a reference to a mutable value of the '<code>timePartitioning</code>'
   * property.
   *
   * Time-based partitioning specification for the destination table. Only one
   * of timePartitioning and rangePartitioning should be specified.
   *
   * @return The result can be modified to change the attribute value.
   */
  TimePartitioning mutable_timePartitioning();

  /**
   * Determine if the '<code>useLegacySql</code>' attribute was set.
   *
   * @return true if the '<code>useLegacySql</code>' attribute was set.
   */
  bool has_use_legacy_sql() const {
    return Storage().isMember("useLegacySql");
  }

  /**
   * Clears the '<code>useLegacySql</code>' attribute.
   */
  void clear_use_legacy_sql() {
    MutableStorage()->removeMember("useLegacySql");
  }


  /**
   * Get the value of the '<code>useLegacySql</code>' attribute.
   */
  bool get_use_legacy_sql() const {
    const Json::Value& storage = Storage("useLegacySql");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>useLegacySql</code>' attribute.
   *
   * Specifies whether to use BigQuery's legacy SQL dialect for this query. The
   * default value is true. If set to false, the query will use BigQuery's
   * standard SQL: https://cloud.google.com/bigquery/sql-reference/ When
   * useLegacySql is set to false, the value of flattenResults is ignored; query
   * will be run as if flattenResults is false.
   *
   * @param[in] value The new value.
   */
  void set_use_legacy_sql(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("useLegacySql"));
  }

  /**
   * Determine if the '<code>useQueryCache</code>' attribute was set.
   *
   * @return true if the '<code>useQueryCache</code>' attribute was set.
   */
  bool has_use_query_cache() const {
    return Storage().isMember("useQueryCache");
  }

  /**
   * Clears the '<code>useQueryCache</code>' attribute.
   */
  void clear_use_query_cache() {
    MutableStorage()->removeMember("useQueryCache");
  }


  /**
   * Get the value of the '<code>useQueryCache</code>' attribute.
   */
  bool get_use_query_cache() const {
    const Json::Value& storage = Storage("useQueryCache");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>useQueryCache</code>' attribute.
   *
   * [Optional] Whether to look for the result in the query cache. The query
   * cache is a best-effort cache that will be flushed whenever tables in the
   * query are modified. Moreover, the query cache is only available when a
   * query does not have a destination table specified. The default value is
   * true.
   *
   * @param[in] value The new value.
   */
  void set_use_query_cache(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("useQueryCache"));
  }

  /**
   * Determine if the '<code>userDefinedFunctionResources</code>' attribute was
   * set.
   *
   * @return true if the '<code>userDefinedFunctionResources</code>' attribute
   * was set.
   */
  bool has_user_defined_function_resources() const {
    return Storage().isMember("userDefinedFunctionResources");
  }

  /**
   * Clears the '<code>userDefinedFunctionResources</code>' attribute.
   */
  void clear_user_defined_function_resources() {
    MutableStorage()->removeMember("userDefinedFunctionResources");
  }


  /**
   * Get a reference to the value of the
   * '<code>userDefinedFunctionResources</code>' attribute.
   */
  const client::JsonCppArray<UserDefinedFunctionResource > get_user_defined_function_resources() const;

  /**
   * Gets a reference to a mutable value of the
   * '<code>userDefinedFunctionResources</code>' property.
   *
   * Describes user-defined function resources used in the query.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppArray<UserDefinedFunctionResource > mutable_userDefinedFunctionResources();

  /**
   * Determine if the '<code>writeDisposition</code>' attribute was set.
   *
   * @return true if the '<code>writeDisposition</code>' attribute was set.
   */
  bool has_write_disposition() const {
    return Storage().isMember("writeDisposition");
  }

  /**
   * Clears the '<code>writeDisposition</code>' attribute.
   */
  void clear_write_disposition() {
    MutableStorage()->removeMember("writeDisposition");
  }


  /**
   * Get the value of the '<code>writeDisposition</code>' attribute.
   */
  const StringPiece get_write_disposition() const {
    const Json::Value& v = Storage("writeDisposition");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>writeDisposition</code>' attribute.
   *
   * [Optional] Specifies the action that occurs if the destination table
   * already exists. The following values are supported: WRITE_TRUNCATE: If the
   * table already exists, BigQuery overwrites the table data and uses the
   * schema from the query result. WRITE_APPEND: If the table already exists,
   * BigQuery appends the data to the table. WRITE_EMPTY: If the table already
   * exists and contains data, a 'duplicate' error is returned in the job
   * result. The default value is WRITE_EMPTY. Each action is atomic and only
   * occurs if BigQuery is able to complete the job successfully. Creation,
   * truncation and append actions occur as one atomic update upon job
   * completion.
   *
   * @param[in] value The new value.
   */
  void set_write_disposition(const StringPiece& value) {
    *MutableStorage("writeDisposition") = value.data();
  }

 private:
  void operator=(const JobConfigurationQuery&);
};  // JobConfigurationQuery
}  // namespace google_bigquery_api
#endif  // GOOGLE_BIGQUERY_API_JOB_CONFIGURATION_QUERY_H_
