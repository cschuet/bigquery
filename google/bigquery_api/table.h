// Copyright 2010 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

// This code was generated by google-apis-code-generator 1.5.1
//   Build date: 2018-10-08 17:45:39 UTC
//   on: 2019-03-01, 03:01:16 UTC
//   C++ generator version: 0.1.4

// ----------------------------------------------------------------------------
// NOTE: This file is generated from Google APIs Discovery Service.
// Service:
//   BigQuery API (bigquery/v2)
// Generated from:
//   Version: v2
//   Revision: 427
// Generated by:
//    Tool: google-apis-code-generator 1.5.1
//     C++: 0.1.4
#ifndef  GOOGLE_BIGQUERY_API_TABLE_H_
#define  GOOGLE_BIGQUERY_API_TABLE_H_

#include <string>
#include "googleapis/base/integral_types.h"
#include "googleapis/base/macros.h"
#include "googleapis/client/data/jsoncpp_data.h"
#include "googleapis/strings/stringpiece.h"

#include "google/bigquery_api/clustering.h"
#include "google/bigquery_api/encryption_configuration.h"
#include "google/bigquery_api/external_data_configuration.h"
#include "google/bigquery_api/materialized_view_definition.h"
#include "google/bigquery_api/model_definition.h"
#include "google/bigquery_api/range_partitioning.h"
#include "google/bigquery_api/streamingbuffer.h"
#include "google/bigquery_api/table_reference.h"
#include "google/bigquery_api/table_schema.h"
#include "google/bigquery_api/time_partitioning.h"
#include "google/bigquery_api/view_definition.h"

namespace Json {
class Value;
}  // namespace Json

namespace google_bigquery_api {
using namespace googleapis;

/**
 * No description provided.
 *
 * @ingroup DataObject
 */
class Table : public client::JsonCppData {
 public:
  /**
   * Creates a new default instance.
   *
   * @return Ownership is passed back to the caller.
   */
  static Table* New();

  /**
   * Standard constructor for an immutable data object instance.
   *
   * @param[in] storage  The underlying data storage for this instance.
   */
  explicit Table(const Json::Value& storage);

  /**
   * Standard constructor for a mutable data object instance.
   *
   * @param[in] storage  The underlying data storage for this instance.
   */
  explicit Table(Json::Value* storage);

  /**
   * Standard destructor.
   */
  virtual ~Table();

  /**
   * Returns a string denoting the type of this data object.
   *
   * @return <code>google_bigquery_api::Table</code>
   */
  const StringPiece GetTypeName() const {
    return StringPiece("google_bigquery_api::Table");
  }

  /**
   * Determine if the '<code>clustering</code>' attribute was set.
   *
   * @return true if the '<code>clustering</code>' attribute was set.
   */
  bool has_clustering() const {
    return Storage().isMember("clustering");
  }

  /**
   * Clears the '<code>clustering</code>' attribute.
   */
  void clear_clustering() {
    MutableStorage()->removeMember("clustering");
  }


  /**
   * Get a reference to the value of the '<code>clustering</code>' attribute.
   */
  const Clustering get_clustering() const;

  /**
   * Gets a reference to a mutable value of the '<code>clustering</code>'
   * property.
   *
   * [Beta] Clustering specification for the table. Must be specified with
   * partitioning, data in the table will be first partitioned and subsequently
   * clustered.
   *
   * @return The result can be modified to change the attribute value.
   */
  Clustering mutable_clustering();

  /**
   * Determine if the '<code>creationTime</code>' attribute was set.
   *
   * @return true if the '<code>creationTime</code>' attribute was set.
   */
  bool has_creation_time() const {
    return Storage().isMember("creationTime");
  }

  /**
   * Clears the '<code>creationTime</code>' attribute.
   */
  void clear_creation_time() {
    MutableStorage()->removeMember("creationTime");
  }


  /**
   * Get the value of the '<code>creationTime</code>' attribute.
   */
  int64 get_creation_time() const {
    const Json::Value& storage = Storage("creationTime");
    return client::JsonValueToCppValueHelper<int64 >(storage);
  }

  /**
   * Change the '<code>creationTime</code>' attribute.
   *
   * [Output-only] The time when this table was created, in milliseconds since
   * the epoch.
   *
   * @param[in] value The new value.
   */
  void set_creation_time(int64 value) {
    client::SetJsonValueFromCppValueHelper<int64 >(
      value, MutableStorage("creationTime"));
  }

  /**
   * Determine if the '<code>description</code>' attribute was set.
   *
   * @return true if the '<code>description</code>' attribute was set.
   */
  bool has_description() const {
    return Storage().isMember("description");
  }

  /**
   * Clears the '<code>description</code>' attribute.
   */
  void clear_description() {
    MutableStorage()->removeMember("description");
  }


  /**
   * Get the value of the '<code>description</code>' attribute.
   */
  const StringPiece get_description() const {
    const Json::Value& v = Storage("description");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>description</code>' attribute.
   *
   * [Optional] A user-friendly description of this table.
   *
   * @param[in] value The new value.
   */
  void set_description(const StringPiece& value) {
    *MutableStorage("description") = value.data();
  }

  /**
   * Determine if the '<code>encryptionConfiguration</code>' attribute was set.
   *
   * @return true if the '<code>encryptionConfiguration</code>' attribute was
   * set.
   */
  bool has_encryption_configuration() const {
    return Storage().isMember("encryptionConfiguration");
  }

  /**
   * Clears the '<code>encryptionConfiguration</code>' attribute.
   */
  void clear_encryption_configuration() {
    MutableStorage()->removeMember("encryptionConfiguration");
  }


  /**
   * Get a reference to the value of the '<code>encryptionConfiguration</code>'
   * attribute.
   */
  const EncryptionConfiguration get_encryption_configuration() const;

  /**
   * Gets a reference to a mutable value of the
   * '<code>encryptionConfiguration</code>' property.
   *
   * Custom encryption configuration (e.g., Cloud KMS keys).
   *
   * @return The result can be modified to change the attribute value.
   */
  EncryptionConfiguration mutable_encryptionConfiguration();

  /**
   * Determine if the '<code>etag</code>' attribute was set.
   *
   * @return true if the '<code>etag</code>' attribute was set.
   */
  bool has_etag() const {
    return Storage().isMember("etag");
  }

  /**
   * Clears the '<code>etag</code>' attribute.
   */
  void clear_etag() {
    MutableStorage()->removeMember("etag");
  }


  /**
   * Get the value of the '<code>etag</code>' attribute.
   */
  const StringPiece get_etag() const {
    const Json::Value& v = Storage("etag");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>etag</code>' attribute.
   *
   * [Output-only] A hash of the table metadata. Used to ensure there were no
   * concurrent modifications to the resource when attempting an update. Not
   * guaranteed to change when the table contents or the fields numRows,
   * numBytes, numLongTermBytes or lastModifiedTime change.
   *
   * @param[in] value The new value.
   */
  void set_etag(const StringPiece& value) {
    *MutableStorage("etag") = value.data();
  }

  /**
   * Determine if the '<code>expirationTime</code>' attribute was set.
   *
   * @return true if the '<code>expirationTime</code>' attribute was set.
   */
  bool has_expiration_time() const {
    return Storage().isMember("expirationTime");
  }

  /**
   * Clears the '<code>expirationTime</code>' attribute.
   */
  void clear_expiration_time() {
    MutableStorage()->removeMember("expirationTime");
  }


  /**
   * Get the value of the '<code>expirationTime</code>' attribute.
   */
  int64 get_expiration_time() const {
    const Json::Value& storage = Storage("expirationTime");
    return client::JsonValueToCppValueHelper<int64 >(storage);
  }

  /**
   * Change the '<code>expirationTime</code>' attribute.
   *
   * [Optional] The time when this table expires, in milliseconds since the
   * epoch. If not present, the table will persist indefinitely. Expired tables
   * will be deleted and their storage reclaimed. The defaultTableExpirationMs
   * property of the encapsulating dataset can be used to set a default
   * expirationTime on newly created tables.
   *
   * @param[in] value The new value.
   */
  void set_expiration_time(int64 value) {
    client::SetJsonValueFromCppValueHelper<int64 >(
      value, MutableStorage("expirationTime"));
  }

  /**
   * Determine if the '<code>externalDataConfiguration</code>' attribute was
   * set.
   *
   * @return true if the '<code>externalDataConfiguration</code>' attribute was
   * set.
   */
  bool has_external_data_configuration() const {
    return Storage().isMember("externalDataConfiguration");
  }

  /**
   * Clears the '<code>externalDataConfiguration</code>' attribute.
   */
  void clear_external_data_configuration() {
    MutableStorage()->removeMember("externalDataConfiguration");
  }


  /**
   * Get a reference to the value of the
   * '<code>externalDataConfiguration</code>' attribute.
   */
  const ExternalDataConfiguration get_external_data_configuration() const;

  /**
   * Gets a reference to a mutable value of the
   * '<code>externalDataConfiguration</code>' property.
   *
   * [Optional] Describes the data format, location, and other properties of a
   * table stored outside of BigQuery. By defining these properties, the data
   * source can then be queried as if it were a standard BigQuery table.
   *
   * @return The result can be modified to change the attribute value.
   */
  ExternalDataConfiguration mutable_externalDataConfiguration();

  /**
   * Determine if the '<code>friendlyName</code>' attribute was set.
   *
   * @return true if the '<code>friendlyName</code>' attribute was set.
   */
  bool has_friendly_name() const {
    return Storage().isMember("friendlyName");
  }

  /**
   * Clears the '<code>friendlyName</code>' attribute.
   */
  void clear_friendly_name() {
    MutableStorage()->removeMember("friendlyName");
  }


  /**
   * Get the value of the '<code>friendlyName</code>' attribute.
   */
  const StringPiece get_friendly_name() const {
    const Json::Value& v = Storage("friendlyName");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>friendlyName</code>' attribute.
   *
   * [Optional] A descriptive name for this table.
   *
   * @param[in] value The new value.
   */
  void set_friendly_name(const StringPiece& value) {
    *MutableStorage("friendlyName") = value.data();
  }

  /**
   * Determine if the '<code>id</code>' attribute was set.
   *
   * @return true if the '<code>id</code>' attribute was set.
   */
  bool has_id() const {
    return Storage().isMember("id");
  }

  /**
   * Clears the '<code>id</code>' attribute.
   */
  void clear_id() {
    MutableStorage()->removeMember("id");
  }


  /**
   * Get the value of the '<code>id</code>' attribute.
   */
  const StringPiece get_id() const {
    const Json::Value& v = Storage("id");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>id</code>' attribute.
   *
   * [Output-only] An opaque ID uniquely identifying the table.
   *
   * @param[in] value The new value.
   */
  void set_id(const StringPiece& value) {
    *MutableStorage("id") = value.data();
  }

  /**
   * Determine if the '<code>kind</code>' attribute was set.
   *
   * @return true if the '<code>kind</code>' attribute was set.
   */
  bool has_kind() const {
    return Storage().isMember("kind");
  }

  /**
   * Clears the '<code>kind</code>' attribute.
   */
  void clear_kind() {
    MutableStorage()->removeMember("kind");
  }


  /**
   * Get the value of the '<code>kind</code>' attribute.
   */
  const StringPiece get_kind() const {
    const Json::Value& v = Storage("kind");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>kind</code>' attribute.
   *
   * [Output-only] The type of the resource.
   *
   * @param[in] value The new value.
   */
  void set_kind(const StringPiece& value) {
    *MutableStorage("kind") = value.data();
  }

  /**
   * Determine if the '<code>labels</code>' attribute was set.
   *
   * @return true if the '<code>labels</code>' attribute was set.
   */
  bool has_labels() const {
    return Storage().isMember("labels");
  }

  /**
   * Clears the '<code>labels</code>' attribute.
   */
  void clear_labels() {
    MutableStorage()->removeMember("labels");
  }


  /**
   * Get a reference to the value of the '<code>labels</code>' attribute.
   */
  const client::JsonCppAssociativeArray<string > get_labels() const {
     const Json::Value& storage = Storage("labels");
    return client::JsonValueToCppValueHelper<client::JsonCppAssociativeArray<string > >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>labels</code>' property.
   *
   * The labels associated with this table. You can use these to organize and
   * group your tables. Label keys and values can be no longer than 63
   * characters, can only contain lowercase letters, numeric characters,
   * underscores and dashes. International characters are allowed. Label values
   * are optional. Label keys must start with a letter and each label in the
   * list must have a different key.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppAssociativeArray<string > mutable_labels() {
    Json::Value* storage = MutableStorage("labels");
    return client::JsonValueToMutableCppValueHelper<client::JsonCppAssociativeArray<string > >(storage);
  }

  /**
   * Determine if the '<code>lastModifiedTime</code>' attribute was set.
   *
   * @return true if the '<code>lastModifiedTime</code>' attribute was set.
   */
  bool has_last_modified_time() const {
    return Storage().isMember("lastModifiedTime");
  }

  /**
   * Clears the '<code>lastModifiedTime</code>' attribute.
   */
  void clear_last_modified_time() {
    MutableStorage()->removeMember("lastModifiedTime");
  }


  /**
   * Get the value of the '<code>lastModifiedTime</code>' attribute.
   */
  uint64 get_last_modified_time() const {
    const Json::Value& storage = Storage("lastModifiedTime");
    return client::JsonValueToCppValueHelper<uint64 >(storage);
  }

  /**
   * Change the '<code>lastModifiedTime</code>' attribute.
   *
   * [Output-only] The time when this table was last modified, in milliseconds
   * since the epoch.
   *
   * @param[in] value The new value.
   */
  void set_last_modified_time(uint64 value) {
    client::SetJsonValueFromCppValueHelper<uint64 >(
      value, MutableStorage("lastModifiedTime"));
  }

  /**
   * Determine if the '<code>location</code>' attribute was set.
   *
   * @return true if the '<code>location</code>' attribute was set.
   */
  bool has_location() const {
    return Storage().isMember("location");
  }

  /**
   * Clears the '<code>location</code>' attribute.
   */
  void clear_location() {
    MutableStorage()->removeMember("location");
  }


  /**
   * Get the value of the '<code>location</code>' attribute.
   */
  const StringPiece get_location() const {
    const Json::Value& v = Storage("location");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>location</code>' attribute.
   *
   * [Output-only] The geographic location where the table resides. This value
   * is inherited from the dataset.
   *
   * @param[in] value The new value.
   */
  void set_location(const StringPiece& value) {
    *MutableStorage("location") = value.data();
  }

  /**
   * Determine if the '<code>materializedView</code>' attribute was set.
   *
   * @return true if the '<code>materializedView</code>' attribute was set.
   */
  bool has_materialized_view() const {
    return Storage().isMember("materializedView");
  }

  /**
   * Clears the '<code>materializedView</code>' attribute.
   */
  void clear_materialized_view() {
    MutableStorage()->removeMember("materializedView");
  }


  /**
   * Get a reference to the value of the '<code>materializedView</code>'
   * attribute.
   */
  const MaterializedViewDefinition get_materialized_view() const;

  /**
   * Gets a reference to a mutable value of the '<code>materializedView</code>'
   * property.
   *
   * [Optional] Materialized view definition.
   *
   * @return The result can be modified to change the attribute value.
   */
  MaterializedViewDefinition mutable_materializedView();

  /**
   * Determine if the '<code>model</code>' attribute was set.
   *
   * @return true if the '<code>model</code>' attribute was set.
   */
  bool has_model() const {
    return Storage().isMember("model");
  }

  /**
   * Clears the '<code>model</code>' attribute.
   */
  void clear_model() {
    MutableStorage()->removeMember("model");
  }


  /**
   * Get a reference to the value of the '<code>model</code>' attribute.
   */
  const ModelDefinition get_model() const;

  /**
   * Gets a reference to a mutable value of the '<code>model</code>' property.
   *
   * [Output-only, Beta] Present iff this table represents a ML model. Describes
   * the training information for the model, and it is required to run 'PREDICT'
   * queries.
   *
   * @return The result can be modified to change the attribute value.
   */
  ModelDefinition mutable_model();

  /**
   * Determine if the '<code>numBytes</code>' attribute was set.
   *
   * @return true if the '<code>numBytes</code>' attribute was set.
   */
  bool has_num_bytes() const {
    return Storage().isMember("numBytes");
  }

  /**
   * Clears the '<code>numBytes</code>' attribute.
   */
  void clear_num_bytes() {
    MutableStorage()->removeMember("numBytes");
  }


  /**
   * Get the value of the '<code>numBytes</code>' attribute.
   */
  int64 get_num_bytes() const {
    const Json::Value& storage = Storage("numBytes");
    return client::JsonValueToCppValueHelper<int64 >(storage);
  }

  /**
   * Change the '<code>numBytes</code>' attribute.
   *
   * [Output-only] The size of this table in bytes, excluding any data in the
   * streaming buffer.
   *
   * @param[in] value The new value.
   */
  void set_num_bytes(int64 value) {
    client::SetJsonValueFromCppValueHelper<int64 >(
      value, MutableStorage("numBytes"));
  }

  /**
   * Determine if the '<code>numLongTermBytes</code>' attribute was set.
   *
   * @return true if the '<code>numLongTermBytes</code>' attribute was set.
   */
  bool has_num_long_term_bytes() const {
    return Storage().isMember("numLongTermBytes");
  }

  /**
   * Clears the '<code>numLongTermBytes</code>' attribute.
   */
  void clear_num_long_term_bytes() {
    MutableStorage()->removeMember("numLongTermBytes");
  }


  /**
   * Get the value of the '<code>numLongTermBytes</code>' attribute.
   */
  int64 get_num_long_term_bytes() const {
    const Json::Value& storage = Storage("numLongTermBytes");
    return client::JsonValueToCppValueHelper<int64 >(storage);
  }

  /**
   * Change the '<code>numLongTermBytes</code>' attribute.
   *
   * [Output-only] The number of bytes in the table that are considered "long-
   * term storage".
   *
   * @param[in] value The new value.
   */
  void set_num_long_term_bytes(int64 value) {
    client::SetJsonValueFromCppValueHelper<int64 >(
      value, MutableStorage("numLongTermBytes"));
  }

  /**
   * Determine if the '<code>numPhysicalBytes</code>' attribute was set.
   *
   * @return true if the '<code>numPhysicalBytes</code>' attribute was set.
   */
  bool has_num_physical_bytes() const {
    return Storage().isMember("numPhysicalBytes");
  }

  /**
   * Clears the '<code>numPhysicalBytes</code>' attribute.
   */
  void clear_num_physical_bytes() {
    MutableStorage()->removeMember("numPhysicalBytes");
  }


  /**
   * Get the value of the '<code>numPhysicalBytes</code>' attribute.
   */
  int64 get_num_physical_bytes() const {
    const Json::Value& storage = Storage("numPhysicalBytes");
    return client::JsonValueToCppValueHelper<int64 >(storage);
  }

  /**
   * Change the '<code>numPhysicalBytes</code>' attribute.
   *
   * [Output-only] [TrustedTester] The physical size of this table in bytes,
   * excluding any data in the streaming buffer. This includes compression and
   * storage used for time travel.
   *
   * @param[in] value The new value.
   */
  void set_num_physical_bytes(int64 value) {
    client::SetJsonValueFromCppValueHelper<int64 >(
      value, MutableStorage("numPhysicalBytes"));
  }

  /**
   * Determine if the '<code>numRows</code>' attribute was set.
   *
   * @return true if the '<code>numRows</code>' attribute was set.
   */
  bool has_num_rows() const {
    return Storage().isMember("numRows");
  }

  /**
   * Clears the '<code>numRows</code>' attribute.
   */
  void clear_num_rows() {
    MutableStorage()->removeMember("numRows");
  }


  /**
   * Get the value of the '<code>numRows</code>' attribute.
   */
  uint64 get_num_rows() const {
    const Json::Value& storage = Storage("numRows");
    return client::JsonValueToCppValueHelper<uint64 >(storage);
  }

  /**
   * Change the '<code>numRows</code>' attribute.
   *
   * [Output-only] The number of rows of data in this table, excluding any data
   * in the streaming buffer.
   *
   * @param[in] value The new value.
   */
  void set_num_rows(uint64 value) {
    client::SetJsonValueFromCppValueHelper<uint64 >(
      value, MutableStorage("numRows"));
  }

  /**
   * Determine if the '<code>rangePartitioning</code>' attribute was set.
   *
   * @return true if the '<code>rangePartitioning</code>' attribute was set.
   */
  bool has_range_partitioning() const {
    return Storage().isMember("rangePartitioning");
  }

  /**
   * Clears the '<code>rangePartitioning</code>' attribute.
   */
  void clear_range_partitioning() {
    MutableStorage()->removeMember("rangePartitioning");
  }


  /**
   * Get a reference to the value of the '<code>rangePartitioning</code>'
   * attribute.
   */
  const RangePartitioning get_range_partitioning() const;

  /**
   * Gets a reference to a mutable value of the '<code>rangePartitioning</code>'
   * property.
   *
   * [TrustedTester] Range partitioning specification for this table. Only one
   * of timePartitioning and rangePartitioning should be specified.
   *
   * @return The result can be modified to change the attribute value.
   */
  RangePartitioning mutable_rangePartitioning();

  /**
   * Determine if the '<code>requirePartitionFilter</code>' attribute was set.
   *
   * @return true if the '<code>requirePartitionFilter</code>' attribute was
   * set.
   */
  bool has_require_partition_filter() const {
    return Storage().isMember("requirePartitionFilter");
  }

  /**
   * Clears the '<code>requirePartitionFilter</code>' attribute.
   */
  void clear_require_partition_filter() {
    MutableStorage()->removeMember("requirePartitionFilter");
  }


  /**
   * Get the value of the '<code>requirePartitionFilter</code>' attribute.
   */
  bool get_require_partition_filter() const {
    const Json::Value& storage = Storage("requirePartitionFilter");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>requirePartitionFilter</code>' attribute.
   *
   * [Beta] [Optional] If set to true, queries over this table require a
   * partition filter that can be used for partition elimination to be
   * specified.
   *
   * @param[in] value The new value.
   */
  void set_require_partition_filter(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("requirePartitionFilter"));
  }

  /**
   * Determine if the '<code>schema</code>' attribute was set.
   *
   * @return true if the '<code>schema</code>' attribute was set.
   */
  bool has_schema() const {
    return Storage().isMember("schema");
  }

  /**
   * Clears the '<code>schema</code>' attribute.
   */
  void clear_schema() {
    MutableStorage()->removeMember("schema");
  }


  /**
   * Get a reference to the value of the '<code>schema</code>' attribute.
   */
  const TableSchema get_schema() const;

  /**
   * Gets a reference to a mutable value of the '<code>schema</code>' property.
   *
   * [Optional] Describes the schema of this table.
   *
   * @return The result can be modified to change the attribute value.
   */
  TableSchema mutable_schema();

  /**
   * Determine if the '<code>selfLink</code>' attribute was set.
   *
   * @return true if the '<code>selfLink</code>' attribute was set.
   */
  bool has_self_link() const {
    return Storage().isMember("selfLink");
  }

  /**
   * Clears the '<code>selfLink</code>' attribute.
   */
  void clear_self_link() {
    MutableStorage()->removeMember("selfLink");
  }


  /**
   * Get the value of the '<code>selfLink</code>' attribute.
   */
  const StringPiece get_self_link() const {
    const Json::Value& v = Storage("selfLink");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>selfLink</code>' attribute.
   *
   * [Output-only] A URL that can be used to access this resource again.
   *
   * @param[in] value The new value.
   */
  void set_self_link(const StringPiece& value) {
    *MutableStorage("selfLink") = value.data();
  }

  /**
   * Determine if the '<code>streamingBuffer</code>' attribute was set.
   *
   * @return true if the '<code>streamingBuffer</code>' attribute was set.
   */
  bool has_streaming_buffer() const {
    return Storage().isMember("streamingBuffer");
  }

  /**
   * Clears the '<code>streamingBuffer</code>' attribute.
   */
  void clear_streaming_buffer() {
    MutableStorage()->removeMember("streamingBuffer");
  }


  /**
   * Get a reference to the value of the '<code>streamingBuffer</code>'
   * attribute.
   */
  const Streamingbuffer get_streaming_buffer() const;

  /**
   * Gets a reference to a mutable value of the '<code>streamingBuffer</code>'
   * property.
   *
   * [Output-only] Contains information regarding this table's streaming buffer,
   * if one is present. This field will be absent if the table is not being
   * streamed to or if there is no data in the streaming buffer.
   *
   * @return The result can be modified to change the attribute value.
   */
  Streamingbuffer mutable_streamingBuffer();

  /**
   * Determine if the '<code>tableReference</code>' attribute was set.
   *
   * @return true if the '<code>tableReference</code>' attribute was set.
   */
  bool has_table_reference() const {
    return Storage().isMember("tableReference");
  }

  /**
   * Clears the '<code>tableReference</code>' attribute.
   */
  void clear_table_reference() {
    MutableStorage()->removeMember("tableReference");
  }


  /**
   * Get a reference to the value of the '<code>tableReference</code>'
   * attribute.
   */
  const TableReference get_table_reference() const;

  /**
   * Gets a reference to a mutable value of the '<code>tableReference</code>'
   * property.
   *
   * [Required] Reference describing the ID of this table.
   *
   * @return The result can be modified to change the attribute value.
   */
  TableReference mutable_tableReference();

  /**
   * Determine if the '<code>timePartitioning</code>' attribute was set.
   *
   * @return true if the '<code>timePartitioning</code>' attribute was set.
   */
  bool has_time_partitioning() const {
    return Storage().isMember("timePartitioning");
  }

  /**
   * Clears the '<code>timePartitioning</code>' attribute.
   */
  void clear_time_partitioning() {
    MutableStorage()->removeMember("timePartitioning");
  }


  /**
   * Get a reference to the value of the '<code>timePartitioning</code>'
   * attribute.
   */
  const TimePartitioning get_time_partitioning() const;

  /**
   * Gets a reference to a mutable value of the '<code>timePartitioning</code>'
   * property.
   *
   * Time-based partitioning specification for this table. Only one of
   * timePartitioning and rangePartitioning should be specified.
   *
   * @return The result can be modified to change the attribute value.
   */
  TimePartitioning mutable_timePartitioning();

  /**
   * Determine if the '<code>type</code>' attribute was set.
   *
   * @return true if the '<code>type</code>' attribute was set.
   */
  bool has_type() const {
    return Storage().isMember("type");
  }

  /**
   * Clears the '<code>type</code>' attribute.
   */
  void clear_type() {
    MutableStorage()->removeMember("type");
  }


  /**
   * Get the value of the '<code>type</code>' attribute.
   */
  const StringPiece get_type() const {
    const Json::Value& v = Storage("type");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>type</code>' attribute.
   *
   * [Output-only] Describes the table type. The following values are supported:
   * TABLE: A normal BigQuery table. VIEW: A virtual table defined by a SQL
   * query. [TrustedTester] MATERIALIZED_VIEW: SQL query whose result is
   * persisted. EXTERNAL: A table that references data stored in an external
   * storage system, such as Google Cloud Storage. The default value is TABLE.
   *
   * @param[in] value The new value.
   */
  void set_type(const StringPiece& value) {
    *MutableStorage("type") = value.data();
  }

  /**
   * Determine if the '<code>view</code>' attribute was set.
   *
   * @return true if the '<code>view</code>' attribute was set.
   */
  bool has_view() const {
    return Storage().isMember("view");
  }

  /**
   * Clears the '<code>view</code>' attribute.
   */
  void clear_view() {
    MutableStorage()->removeMember("view");
  }


  /**
   * Get a reference to the value of the '<code>view</code>' attribute.
   */
  const ViewDefinition get_view() const;

  /**
   * Gets a reference to a mutable value of the '<code>view</code>' property.
   *
   * [Optional] The view definition.
   *
   * @return The result can be modified to change the attribute value.
   */
  ViewDefinition mutable_view();

 private:
  void operator=(const Table&);
};  // Table
}  // namespace google_bigquery_api
#endif  // GOOGLE_BIGQUERY_API_TABLE_H_
