// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

// This code was generated by google-apis-code-generator 1.6.0

// ----------------------------------------------------------------------------
// NOTE: This file is generated from Google API Discovery Service.
// Service:
//   BigQuery API (bigquery/v2)
// Generated from:
//   Version: v2
//   Revision: 20190224
// Generated by:
//    Tool: google-apis-code-generator 1.6.0
//     C++: 0.1.5
#ifndef  GOOGLE_BIGQUERY_API_JOB_CONFIGURATION_LOAD_H_
#define  GOOGLE_BIGQUERY_API_JOB_CONFIGURATION_LOAD_H_

#include <string>
#include "googleapis/base/integral_types.h"
#include "googleapis/client/data/jsoncpp_data.h"

#include "google/bigquery_api/clustering.h"
#include "google/bigquery_api/destination_table_properties.h"
#include "google/bigquery_api/encryption_configuration.h"
#include "google/bigquery_api/range_partitioning.h"
#include "google/bigquery_api/table_reference.h"
#include "google/bigquery_api/table_schema.h"
#include "google/bigquery_api/time_partitioning.h"

namespace Json {
class Value;
}  // namespace Json

namespace google_bigquery_api {
using namespace googleapis;

/**
 * No description provided.
 *
 * @ingroup DataObject
 */
class JobConfigurationLoad : public client::JsonCppData {
 public:
  /**
   * Creates a new default instance.
   *
   * @return Ownership is passed back to the caller.
   */
  static JobConfigurationLoad* New();

  /**
   * Standard constructor for an immutable data object instance.
   *
   * @param[in] storage  The underlying data storage for this instance.
   */
  explicit JobConfigurationLoad(const Json::Value& storage);

  /**
   * Standard constructor for a mutable data object instance.
   *
   * @param[in] storage  The underlying data storage for this instance.
   */
  explicit JobConfigurationLoad(Json::Value* storage);

  /**
   * Standard destructor.
   */
  virtual ~JobConfigurationLoad();

  /**
   * Returns a string denoting the type of this data object.
   *
   * @return <code>google_bigquery_api::JobConfigurationLoad</code>
   */
  const char* GetTypeName() const {
    return "google_bigquery_api::JobConfigurationLoad";
  }

  /**
   * Determine if the '<code>allowJaggedRows</code>' attribute was set.
   *
   * @return true if the '<code>allowJaggedRows</code>' attribute was set.
   */
  bool has_allow_jagged_rows() const {
    return Storage().isMember("allowJaggedRows");
  }

  /**
   * Clears the '<code>allowJaggedRows</code>' attribute.
   */
  void clear_allow_jagged_rows() {
    MutableStorage()->removeMember("allowJaggedRows");
  }


  /**
   * Get the value of the '<code>allowJaggedRows</code>' attribute.
   */
  bool get_allow_jagged_rows() const {
    const Json::Value& storage = Storage("allowJaggedRows");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>allowJaggedRows</code>' attribute.
   *
   * [Optional] Accept rows that are missing trailing optional columns. The
   * missing values are treated as nulls. If false, records with missing
   * trailing columns are treated as bad records, and if there are too many bad
   * records, an invalid error is returned in the job result. The default value
   * is false. Only applicable to CSV, ignored for other formats.
   *
   * @param[in] value The new value.
   */
  void set_allow_jagged_rows(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("allowJaggedRows"));
  }

  /**
   * Determine if the '<code>allowQuotedNewlines</code>' attribute was set.
   *
   * @return true if the '<code>allowQuotedNewlines</code>' attribute was set.
   */
  bool has_allow_quoted_newlines() const {
    return Storage().isMember("allowQuotedNewlines");
  }

  /**
   * Clears the '<code>allowQuotedNewlines</code>' attribute.
   */
  void clear_allow_quoted_newlines() {
    MutableStorage()->removeMember("allowQuotedNewlines");
  }


  /**
   * Get the value of the '<code>allowQuotedNewlines</code>' attribute.
   */
  bool get_allow_quoted_newlines() const {
    const Json::Value& storage = Storage("allowQuotedNewlines");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>allowQuotedNewlines</code>' attribute.
   *
   * Indicates if BigQuery should allow quoted data sections that contain
   * newline characters in a CSV file. The default value is false.
   *
   * @param[in] value The new value.
   */
  void set_allow_quoted_newlines(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("allowQuotedNewlines"));
  }

  /**
   * Determine if the '<code>autodetect</code>' attribute was set.
   *
   * @return true if the '<code>autodetect</code>' attribute was set.
   */
  bool has_autodetect() const {
    return Storage().isMember("autodetect");
  }

  /**
   * Clears the '<code>autodetect</code>' attribute.
   */
  void clear_autodetect() {
    MutableStorage()->removeMember("autodetect");
  }


  /**
   * Get the value of the '<code>autodetect</code>' attribute.
   */
  bool get_autodetect() const {
    const Json::Value& storage = Storage("autodetect");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>autodetect</code>' attribute.
   *
   * [Optional] Indicates if we should automatically infer the options and
   * schema for CSV and JSON sources.
   *
   * @param[in] value The new value.
   */
  void set_autodetect(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("autodetect"));
  }

  /**
   * Determine if the '<code>clustering</code>' attribute was set.
   *
   * @return true if the '<code>clustering</code>' attribute was set.
   */
  bool has_clustering() const {
    return Storage().isMember("clustering");
  }

  /**
   * Clears the '<code>clustering</code>' attribute.
   */
  void clear_clustering() {
    MutableStorage()->removeMember("clustering");
  }


  /**
   * Get a reference to the value of the '<code>clustering</code>' attribute.
   */
  const Clustering get_clustering() const;

  /**
   * Gets a reference to a mutable value of the '<code>clustering</code>'
   * property.
   *
   * [Beta] Clustering specification for the destination table. Must be
   * specified with time-based partitioning, data in the table will be first
   * partitioned and subsequently clustered.
   *
   * @return The result can be modified to change the attribute value.
   */
  Clustering mutable_clustering();

  /**
   * Determine if the '<code>createDisposition</code>' attribute was set.
   *
   * @return true if the '<code>createDisposition</code>' attribute was set.
   */
  bool has_create_disposition() const {
    return Storage().isMember("createDisposition");
  }

  /**
   * Clears the '<code>createDisposition</code>' attribute.
   */
  void clear_create_disposition() {
    MutableStorage()->removeMember("createDisposition");
  }


  /**
   * Get the value of the '<code>createDisposition</code>' attribute.
   */
  const std::string get_create_disposition() const {
    const Json::Value& v = Storage("createDisposition");
    if (v == Json::Value::null) return std::string("");
    return std::string(v.asCString());
  }

  /**
   * Change the '<code>createDisposition</code>' attribute.
   *
   * [Optional] Specifies whether the job is allowed to create new tables. The
   * following values are supported: CREATE_IF_NEEDED: If the table does not
   * exist, BigQuery creates the table. CREATE_NEVER: The table must already
   * exist. If it does not, a 'notFound' error is returned in the job result.
   * The default value is CREATE_IF_NEEDED. Creation, truncation and append
   * actions occur as one atomic update upon job completion.
   *
   * @param[in] value The new value.
   */
  void set_create_disposition(const std::string& value) {
    *MutableStorage("createDisposition") = value.data();
  }

  /**
   * Determine if the '<code>destinationEncryptionConfiguration</code>'
   * attribute was set.
   *
   * @return true if the '<code>destinationEncryptionConfiguration</code>'
   * attribute was set.
   */
  bool has_destination_encryption_configuration() const {
    return Storage().isMember("destinationEncryptionConfiguration");
  }

  /**
   * Clears the '<code>destinationEncryptionConfiguration</code>' attribute.
   */
  void clear_destination_encryption_configuration() {
    MutableStorage()->removeMember("destinationEncryptionConfiguration");
  }


  /**
   * Get a reference to the value of the
   * '<code>destinationEncryptionConfiguration</code>' attribute.
   */
  const EncryptionConfiguration get_destination_encryption_configuration() const;

  /**
   * Gets a reference to a mutable value of the
   * '<code>destinationEncryptionConfiguration</code>' property.
   *
   * Custom encryption configuration (e.g., Cloud KMS keys).
   *
   * @return The result can be modified to change the attribute value.
   */
  EncryptionConfiguration mutable_destinationEncryptionConfiguration();

  /**
   * Determine if the '<code>destinationTable</code>' attribute was set.
   *
   * @return true if the '<code>destinationTable</code>' attribute was set.
   */
  bool has_destination_table() const {
    return Storage().isMember("destinationTable");
  }

  /**
   * Clears the '<code>destinationTable</code>' attribute.
   */
  void clear_destination_table() {
    MutableStorage()->removeMember("destinationTable");
  }


  /**
   * Get a reference to the value of the '<code>destinationTable</code>'
   * attribute.
   */
  const TableReference get_destination_table() const;

  /**
   * Gets a reference to a mutable value of the '<code>destinationTable</code>'
   * property.
   *
   * [Required] The destination table to load the data into.
   *
   * @return The result can be modified to change the attribute value.
   */
  TableReference mutable_destinationTable();

  /**
   * Determine if the '<code>destinationTableProperties</code>' attribute was
   * set.
   *
   * @return true if the '<code>destinationTableProperties</code>' attribute was
   * set.
   */
  bool has_destination_table_properties() const {
    return Storage().isMember("destinationTableProperties");
  }

  /**
   * Clears the '<code>destinationTableProperties</code>' attribute.
   */
  void clear_destination_table_properties() {
    MutableStorage()->removeMember("destinationTableProperties");
  }


  /**
   * Get a reference to the value of the
   * '<code>destinationTableProperties</code>' attribute.
   */
  const DestinationTableProperties get_destination_table_properties() const;

  /**
   * Gets a reference to a mutable value of the
   * '<code>destinationTableProperties</code>' property.
   *
   * [Beta] [Optional] Properties with which to create the destination table if
   * it is new.
   *
   * @return The result can be modified to change the attribute value.
   */
  DestinationTableProperties mutable_destinationTableProperties();

  /**
   * Determine if the '<code>encoding</code>' attribute was set.
   *
   * @return true if the '<code>encoding</code>' attribute was set.
   */
  bool has_encoding() const {
    return Storage().isMember("encoding");
  }

  /**
   * Clears the '<code>encoding</code>' attribute.
   */
  void clear_encoding() {
    MutableStorage()->removeMember("encoding");
  }


  /**
   * Get the value of the '<code>encoding</code>' attribute.
   */
  const std::string get_encoding() const {
    const Json::Value& v = Storage("encoding");
    if (v == Json::Value::null) return std::string("");
    return std::string(v.asCString());
  }

  /**
   * Change the '<code>encoding</code>' attribute.
   *
   * [Optional] The character encoding of the data. The supported values are
   * UTF-8 or ISO-8859-1. The default value is UTF-8. BigQuery decodes the data
   * after the raw, binary data has been split using the values of the quote and
   * fieldDelimiter properties.
   *
   * @param[in] value The new value.
   */
  void set_encoding(const std::string& value) {
    *MutableStorage("encoding") = value.data();
  }

  /**
   * Determine if the '<code>fieldDelimiter</code>' attribute was set.
   *
   * @return true if the '<code>fieldDelimiter</code>' attribute was set.
   */
  bool has_field_delimiter() const {
    return Storage().isMember("fieldDelimiter");
  }

  /**
   * Clears the '<code>fieldDelimiter</code>' attribute.
   */
  void clear_field_delimiter() {
    MutableStorage()->removeMember("fieldDelimiter");
  }


  /**
   * Get the value of the '<code>fieldDelimiter</code>' attribute.
   */
  const std::string get_field_delimiter() const {
    const Json::Value& v = Storage("fieldDelimiter");
    if (v == Json::Value::null) return std::string("");
    return std::string(v.asCString());
  }

  /**
   * Change the '<code>fieldDelimiter</code>' attribute.
   *
   * [Optional] The separator for fields in a CSV file. The separator can be any
   * ISO-8859-1 single-byte character. To use a character in the range 128-255,
   * you must encode the character as UTF8. BigQuery converts the string to
   * ISO-8859-1 encoding, and then uses the first byte of the encoded string to
   * split the data in its raw, binary state. BigQuery also supports the escape
   * sequence "\t" to specify a tab separator. The default value is a comma
   * (',').
   *
   * @param[in] value The new value.
   */
  void set_field_delimiter(const std::string& value) {
    *MutableStorage("fieldDelimiter") = value.data();
  }

  /**
   * Determine if the '<code>hivePartitioningMode</code>' attribute was set.
   *
   * @return true if the '<code>hivePartitioningMode</code>' attribute was set.
   */
  bool has_hive_partitioning_mode() const {
    return Storage().isMember("hivePartitioningMode");
  }

  /**
   * Clears the '<code>hivePartitioningMode</code>' attribute.
   */
  void clear_hive_partitioning_mode() {
    MutableStorage()->removeMember("hivePartitioningMode");
  }


  /**
   * Get the value of the '<code>hivePartitioningMode</code>' attribute.
   */
  const std::string get_hive_partitioning_mode() const {
    const Json::Value& v = Storage("hivePartitioningMode");
    if (v == Json::Value::null) return std::string("");
    return std::string(v.asCString());
  }

  /**
   * Change the '<code>hivePartitioningMode</code>' attribute.
   *
   * [Optional, Experimental] If hive partitioning is enabled, which mode to
   * use. Two modes are supported: - AUTO: automatically infer partition key
   * name(s) and type(s). - STRINGS: automatic infer partition key name(s). All
   * types are strings. Not all storage formats support hive partitioning --
   * requesting hive partitioning on an unsupported format will lead to an
   * error.
   *
   * @param[in] value The new value.
   */
  void set_hive_partitioning_mode(const std::string& value) {
    *MutableStorage("hivePartitioningMode") = value.data();
  }

  /**
   * Determine if the '<code>ignoreUnknownValues</code>' attribute was set.
   *
   * @return true if the '<code>ignoreUnknownValues</code>' attribute was set.
   */
  bool has_ignore_unknown_values() const {
    return Storage().isMember("ignoreUnknownValues");
  }

  /**
   * Clears the '<code>ignoreUnknownValues</code>' attribute.
   */
  void clear_ignore_unknown_values() {
    MutableStorage()->removeMember("ignoreUnknownValues");
  }


  /**
   * Get the value of the '<code>ignoreUnknownValues</code>' attribute.
   */
  bool get_ignore_unknown_values() const {
    const Json::Value& storage = Storage("ignoreUnknownValues");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>ignoreUnknownValues</code>' attribute.
   *
   * [Optional] Indicates if BigQuery should allow extra values that are not
   * represented in the table schema. If true, the extra values are ignored. If
   * false, records with extra columns are treated as bad records, and if there
   * are too many bad records, an invalid error is returned in the job result.
   * The default value is false. The sourceFormat property determines what
   * BigQuery treats as an extra value: CSV: Trailing columns JSON: Named values
   * that don't match any column names.
   *
   * @param[in] value The new value.
   */
  void set_ignore_unknown_values(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("ignoreUnknownValues"));
  }

  /**
   * Determine if the '<code>maxBadRecords</code>' attribute was set.
   *
   * @return true if the '<code>maxBadRecords</code>' attribute was set.
   */
  bool has_max_bad_records() const {
    return Storage().isMember("maxBadRecords");
  }

  /**
   * Clears the '<code>maxBadRecords</code>' attribute.
   */
  void clear_max_bad_records() {
    MutableStorage()->removeMember("maxBadRecords");
  }


  /**
   * Get the value of the '<code>maxBadRecords</code>' attribute.
   */
  int32 get_max_bad_records() const {
    const Json::Value& storage = Storage("maxBadRecords");
    return client::JsonValueToCppValueHelper<int32 >(storage);
  }

  /**
   * Change the '<code>maxBadRecords</code>' attribute.
   *
   * [Optional] The maximum number of bad records that BigQuery can ignore when
   * running the job. If the number of bad records exceeds this value, an
   * invalid error is returned in the job result. This is only valid for CSV and
   * JSON. The default value is 0, which requires that all records are valid.
   *
   * @param[in] value The new value.
   */
  void set_max_bad_records(int32 value) {
    client::SetJsonValueFromCppValueHelper<int32 >(
      value, MutableStorage("maxBadRecords"));
  }

  /**
   * Determine if the '<code>nullMarker</code>' attribute was set.
   *
   * @return true if the '<code>nullMarker</code>' attribute was set.
   */
  bool has_null_marker() const {
    return Storage().isMember("nullMarker");
  }

  /**
   * Clears the '<code>nullMarker</code>' attribute.
   */
  void clear_null_marker() {
    MutableStorage()->removeMember("nullMarker");
  }


  /**
   * Get the value of the '<code>nullMarker</code>' attribute.
   */
  const std::string get_null_marker() const {
    const Json::Value& v = Storage("nullMarker");
    if (v == Json::Value::null) return std::string("");
    return std::string(v.asCString());
  }

  /**
   * Change the '<code>nullMarker</code>' attribute.
   *
   * [Optional] Specifies a string that represents a null value in a CSV file.
   * For example, if you specify "\N", BigQuery interprets "\N" as a null value
   * when loading a CSV file. The default value is the empty string. If you set
   * this property to a custom value, BigQuery throws an error if an empty
   * string is present for all data types except for STRING and BYTE. For STRING
   * and BYTE columns, BigQuery interprets the empty string as an empty value.
   *
   * @param[in] value The new value.
   */
  void set_null_marker(const std::string& value) {
    *MutableStorage("nullMarker") = value.data();
  }

  /**
   * Determine if the '<code>projectionFields</code>' attribute was set.
   *
   * @return true if the '<code>projectionFields</code>' attribute was set.
   */
  bool has_projection_fields() const {
    return Storage().isMember("projectionFields");
  }

  /**
   * Clears the '<code>projectionFields</code>' attribute.
   */
  void clear_projection_fields() {
    MutableStorage()->removeMember("projectionFields");
  }


  /**
   * Get a reference to the value of the '<code>projectionFields</code>'
   * attribute.
   */
  const client::JsonCppArray<string > get_projection_fields() const {
     const Json::Value& storage = Storage("projectionFields");
    return client::JsonValueToCppValueHelper<client::JsonCppArray<string > >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>projectionFields</code>'
   * property.
   *
   * If sourceFormat is set to "DATASTORE_BACKUP", indicates which entity
   * properties to load into BigQuery from a Cloud Datastore backup. Property
   * names are case sensitive and must be top-level properties. If no properties
   * are specified, BigQuery loads all properties. If any named property isn't
   * found in the Cloud Datastore backup, an invalid error is returned in the
   * job result.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppArray<string > mutable_projectionFields() {
    Json::Value* storage = MutableStorage("projectionFields");
    return client::JsonValueToMutableCppValueHelper<client::JsonCppArray<string > >(storage);
  }

  /**
   * Determine if the '<code>quote</code>' attribute was set.
   *
   * @return true if the '<code>quote</code>' attribute was set.
   */
  bool has_quote() const {
    return Storage().isMember("quote");
  }

  /**
   * Clears the '<code>quote</code>' attribute.
   */
  void clear_quote() {
    MutableStorage()->removeMember("quote");
  }


  /**
   * Get the value of the '<code>quote</code>' attribute.
   */
  const std::string get_quote() const {
    const Json::Value& v = Storage("quote");
    if (v == Json::Value::null) return std::string("");
    return std::string(v.asCString());
  }

  /**
   * Change the '<code>quote</code>' attribute.
   *
   * [Optional] The value that is used to quote data sections in a CSV file.
   * BigQuery converts the string to ISO-8859-1 encoding, and then uses the
   * first byte of the encoded string to split the data in its raw, binary
   * state. The default value is a double-quote ('"'). If your data does not
   * contain quoted sections, set the property value to an empty string. If your
   * data contains quoted newline characters, you must also set the
   * allowQuotedNewlines property to true.
   *
   * @param[in] value The new value.
   */
  void set_quote(const std::string& value) {
    *MutableStorage("quote") = value.data();
  }

  /**
   * Determine if the '<code>rangePartitioning</code>' attribute was set.
   *
   * @return true if the '<code>rangePartitioning</code>' attribute was set.
   */
  bool has_range_partitioning() const {
    return Storage().isMember("rangePartitioning");
  }

  /**
   * Clears the '<code>rangePartitioning</code>' attribute.
   */
  void clear_range_partitioning() {
    MutableStorage()->removeMember("rangePartitioning");
  }


  /**
   * Get a reference to the value of the '<code>rangePartitioning</code>'
   * attribute.
   */
  const RangePartitioning get_range_partitioning() const;

  /**
   * Gets a reference to a mutable value of the '<code>rangePartitioning</code>'
   * property.
   *
   * [TrustedTester] Range partitioning specification for this table. Only one
   * of timePartitioning and rangePartitioning should be specified.
   *
   * @return The result can be modified to change the attribute value.
   */
  RangePartitioning mutable_rangePartitioning();

  /**
   * Determine if the '<code>schema</code>' attribute was set.
   *
   * @return true if the '<code>schema</code>' attribute was set.
   */
  bool has_schema() const {
    return Storage().isMember("schema");
  }

  /**
   * Clears the '<code>schema</code>' attribute.
   */
  void clear_schema() {
    MutableStorage()->removeMember("schema");
  }


  /**
   * Get a reference to the value of the '<code>schema</code>' attribute.
   */
  const TableSchema get_schema() const;

  /**
   * Gets a reference to a mutable value of the '<code>schema</code>' property.
   *
   * [Optional] The schema for the destination table. The schema can be omitted
   * if the destination table already exists, or if you're loading data from
   * Google Cloud Datastore.
   *
   * @return The result can be modified to change the attribute value.
   */
  TableSchema mutable_schema();

  /**
   * Determine if the '<code>schemaInline</code>' attribute was set.
   *
   * @return true if the '<code>schemaInline</code>' attribute was set.
   */
  bool has_schema_inline() const {
    return Storage().isMember("schemaInline");
  }

  /**
   * Clears the '<code>schemaInline</code>' attribute.
   */
  void clear_schema_inline() {
    MutableStorage()->removeMember("schemaInline");
  }


  /**
   * Get the value of the '<code>schemaInline</code>' attribute.
   */
  const std::string get_schema_inline() const {
    const Json::Value& v = Storage("schemaInline");
    if (v == Json::Value::null) return std::string("");
    return std::string(v.asCString());
  }

  /**
   * Change the '<code>schemaInline</code>' attribute.
   * @deprecated
   *
   *
   * [Deprecated] The inline schema. For CSV schemas, specify as
   * "Field1:Type1[,Field2:Type2]*". For example, "foo:STRING, bar:INTEGER,
   * baz:FLOAT".
   *
   * @param[in] value The new value.
   */
  void set_schema_inline(const std::string& value) {
    *MutableStorage("schemaInline") = value.data();
  }

  /**
   * Determine if the '<code>schemaInlineFormat</code>' attribute was set.
   *
   * @return true if the '<code>schemaInlineFormat</code>' attribute was set.
   */
  bool has_schema_inline_format() const {
    return Storage().isMember("schemaInlineFormat");
  }

  /**
   * Clears the '<code>schemaInlineFormat</code>' attribute.
   */
  void clear_schema_inline_format() {
    MutableStorage()->removeMember("schemaInlineFormat");
  }


  /**
   * Get the value of the '<code>schemaInlineFormat</code>' attribute.
   */
  const std::string get_schema_inline_format() const {
    const Json::Value& v = Storage("schemaInlineFormat");
    if (v == Json::Value::null) return std::string("");
    return std::string(v.asCString());
  }

  /**
   * Change the '<code>schemaInlineFormat</code>' attribute.
   * @deprecated
   *
   *
   * [Deprecated] The format of the schemaInline property.
   *
   * @param[in] value The new value.
   */
  void set_schema_inline_format(const std::string& value) {
    *MutableStorage("schemaInlineFormat") = value.data();
  }

  /**
   * Determine if the '<code>schemaUpdateOptions</code>' attribute was set.
   *
   * @return true if the '<code>schemaUpdateOptions</code>' attribute was set.
   */
  bool has_schema_update_options() const {
    return Storage().isMember("schemaUpdateOptions");
  }

  /**
   * Clears the '<code>schemaUpdateOptions</code>' attribute.
   */
  void clear_schema_update_options() {
    MutableStorage()->removeMember("schemaUpdateOptions");
  }


  /**
   * Get a reference to the value of the '<code>schemaUpdateOptions</code>'
   * attribute.
   */
  const client::JsonCppArray<string > get_schema_update_options() const {
     const Json::Value& storage = Storage("schemaUpdateOptions");
    return client::JsonValueToCppValueHelper<client::JsonCppArray<string > >(storage);
  }

  /**
   * Gets a reference to a mutable value of the
   * '<code>schemaUpdateOptions</code>' property.
   *
   * Allows the schema of the destination table to be updated as a side effect
   * of the load job if a schema is autodetected or supplied in the job
   * configuration. Schema update options are supported in two cases: when
   * writeDisposition is WRITE_APPEND; when writeDisposition is WRITE_TRUNCATE
   * and the destination table is a partition of a table, specified by partition
   * decorators. For normal tables, WRITE_TRUNCATE will always overwrite the
   * schema. One or more of the following values are specified:
   * ALLOW_FIELD_ADDITION: allow adding a nullable field to the schema.
   * ALLOW_FIELD_RELAXATION: allow relaxing a required field in the original
   * schema to nullable.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppArray<string > mutable_schemaUpdateOptions() {
    Json::Value* storage = MutableStorage("schemaUpdateOptions");
    return client::JsonValueToMutableCppValueHelper<client::JsonCppArray<string > >(storage);
  }

  /**
   * Determine if the '<code>skipLeadingRows</code>' attribute was set.
   *
   * @return true if the '<code>skipLeadingRows</code>' attribute was set.
   */
  bool has_skip_leading_rows() const {
    return Storage().isMember("skipLeadingRows");
  }

  /**
   * Clears the '<code>skipLeadingRows</code>' attribute.
   */
  void clear_skip_leading_rows() {
    MutableStorage()->removeMember("skipLeadingRows");
  }


  /**
   * Get the value of the '<code>skipLeadingRows</code>' attribute.
   */
  int32 get_skip_leading_rows() const {
    const Json::Value& storage = Storage("skipLeadingRows");
    return client::JsonValueToCppValueHelper<int32 >(storage);
  }

  /**
   * Change the '<code>skipLeadingRows</code>' attribute.
   *
   * [Optional] The number of rows at the top of a CSV file that BigQuery will
   * skip when loading the data. The default value is 0. This property is useful
   * if you have header rows in the file that should be skipped.
   *
   * @param[in] value The new value.
   */
  void set_skip_leading_rows(int32 value) {
    client::SetJsonValueFromCppValueHelper<int32 >(
      value, MutableStorage("skipLeadingRows"));
  }

  /**
   * Determine if the '<code>sourceFormat</code>' attribute was set.
   *
   * @return true if the '<code>sourceFormat</code>' attribute was set.
   */
  bool has_source_format() const {
    return Storage().isMember("sourceFormat");
  }

  /**
   * Clears the '<code>sourceFormat</code>' attribute.
   */
  void clear_source_format() {
    MutableStorage()->removeMember("sourceFormat");
  }


  /**
   * Get the value of the '<code>sourceFormat</code>' attribute.
   */
  const std::string get_source_format() const {
    const Json::Value& v = Storage("sourceFormat");
    if (v == Json::Value::null) return std::string("");
    return std::string(v.asCString());
  }

  /**
   * Change the '<code>sourceFormat</code>' attribute.
   *
   * [Optional] The format of the data files. For CSV files, specify "CSV". For
   * datastore backups, specify "DATASTORE_BACKUP". For newline-delimited JSON,
   * specify "NEWLINE_DELIMITED_JSON". For Avro, specify "AVRO". For parquet,
   * specify "PARQUET". For orc, specify "ORC". The default value is CSV.
   *
   * @param[in] value The new value.
   */
  void set_source_format(const std::string& value) {
    *MutableStorage("sourceFormat") = value.data();
  }

  /**
   * Determine if the '<code>sourceUris</code>' attribute was set.
   *
   * @return true if the '<code>sourceUris</code>' attribute was set.
   */
  bool has_source_uris() const {
    return Storage().isMember("sourceUris");
  }

  /**
   * Clears the '<code>sourceUris</code>' attribute.
   */
  void clear_source_uris() {
    MutableStorage()->removeMember("sourceUris");
  }


  /**
   * Get a reference to the value of the '<code>sourceUris</code>' attribute.
   */
  const client::JsonCppArray<string > get_source_uris() const {
     const Json::Value& storage = Storage("sourceUris");
    return client::JsonValueToCppValueHelper<client::JsonCppArray<string > >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>sourceUris</code>'
   * property.
   *
   * [Required] The fully-qualified URIs that point to your data in Google
   * Cloud. For Google Cloud Storage URIs: Each URI can contain one '*' wildcard
   * character and it must come after the 'bucket' name. Size limits related to
   * load jobs apply to external data sources. For Google Cloud Bigtable URIs:
   * Exactly one URI can be specified and it has be a fully specified and valid
   * HTTPS URL for a Google Cloud Bigtable table. For Google Cloud Datastore
   * backups: Exactly one URI can be specified. Also, the '*' wildcard character
   * is not allowed.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppArray<string > mutable_sourceUris() {
    Json::Value* storage = MutableStorage("sourceUris");
    return client::JsonValueToMutableCppValueHelper<client::JsonCppArray<string > >(storage);
  }

  /**
   * Determine if the '<code>timePartitioning</code>' attribute was set.
   *
   * @return true if the '<code>timePartitioning</code>' attribute was set.
   */
  bool has_time_partitioning() const {
    return Storage().isMember("timePartitioning");
  }

  /**
   * Clears the '<code>timePartitioning</code>' attribute.
   */
  void clear_time_partitioning() {
    MutableStorage()->removeMember("timePartitioning");
  }


  /**
   * Get a reference to the value of the '<code>timePartitioning</code>'
   * attribute.
   */
  const TimePartitioning get_time_partitioning() const;

  /**
   * Gets a reference to a mutable value of the '<code>timePartitioning</code>'
   * property.
   *
   * Time-based partitioning specification for the destination table. Only one
   * of timePartitioning and rangePartitioning should be specified.
   *
   * @return The result can be modified to change the attribute value.
   */
  TimePartitioning mutable_timePartitioning();

  /**
   * Determine if the '<code>useAvroLogicalTypes</code>' attribute was set.
   *
   * @return true if the '<code>useAvroLogicalTypes</code>' attribute was set.
   */
  bool has_use_avro_logical_types() const {
    return Storage().isMember("useAvroLogicalTypes");
  }

  /**
   * Clears the '<code>useAvroLogicalTypes</code>' attribute.
   */
  void clear_use_avro_logical_types() {
    MutableStorage()->removeMember("useAvroLogicalTypes");
  }


  /**
   * Get the value of the '<code>useAvroLogicalTypes</code>' attribute.
   */
  bool get_use_avro_logical_types() const {
    const Json::Value& storage = Storage("useAvroLogicalTypes");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>useAvroLogicalTypes</code>' attribute.
   *
   * [Optional] If sourceFormat is set to "AVRO", indicates whether to enable
   * interpreting logical types into their corresponding types (ie. TIMESTAMP),
   * instead of only using their raw types (ie. INTEGER).
   *
   * @param[in] value The new value.
   */
  void set_use_avro_logical_types(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("useAvroLogicalTypes"));
  }

  /**
   * Determine if the '<code>writeDisposition</code>' attribute was set.
   *
   * @return true if the '<code>writeDisposition</code>' attribute was set.
   */
  bool has_write_disposition() const {
    return Storage().isMember("writeDisposition");
  }

  /**
   * Clears the '<code>writeDisposition</code>' attribute.
   */
  void clear_write_disposition() {
    MutableStorage()->removeMember("writeDisposition");
  }


  /**
   * Get the value of the '<code>writeDisposition</code>' attribute.
   */
  const std::string get_write_disposition() const {
    const Json::Value& v = Storage("writeDisposition");
    if (v == Json::Value::null) return std::string("");
    return std::string(v.asCString());
  }

  /**
   * Change the '<code>writeDisposition</code>' attribute.
   *
   * [Optional] Specifies the action that occurs if the destination table
   * already exists. The following values are supported: WRITE_TRUNCATE: If the
   * table already exists, BigQuery overwrites the table data. WRITE_APPEND: If
   * the table already exists, BigQuery appends the data to the table.
   * WRITE_EMPTY: If the table already exists and contains data, a 'duplicate'
   * error is returned in the job result. The default value is WRITE_APPEND.
   * Each action is atomic and only occurs if BigQuery is able to complete the
   * job successfully. Creation, truncation and append actions occur as one
   * atomic update upon job completion.
   *
   * @param[in] value The new value.
   */
  void set_write_disposition(const std::string& value) {
    *MutableStorage("writeDisposition") = value.data();
  }

 private:
  void operator=(const JobConfigurationLoad&);
};  // JobConfigurationLoad
}  // namespace google_bigquery_api
#endif  // GOOGLE_BIGQUERY_API_JOB_CONFIGURATION_LOAD_H_
